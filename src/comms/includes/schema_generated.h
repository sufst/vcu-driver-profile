// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCHEMA_COMMS_H_
#define FLATBUFFERS_GENERATED_SCHEMA_COMMS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 && FLATBUFFERS_VERSION_MINOR == 1
                  && FLATBUFFERS_VERSION_REVISION == 21,
              "Non-compatible flatbuffers version included");

namespace Comms
{

struct Version;

struct Command;
struct CommandBuilder;

enum CommandID : int8_t
{
    CommandID_OPEN = 0,
    CommandID_CLOSE = 1,
    CommandID_SET = 2,
    CommandID_GET = 3,
    CommandID_RET = 4,
    CommandID_ERR = 5,
    CommandID_RES = 6,
    CommandID_SAVE = 7,
    CommandID_MIN = CommandID_OPEN,
    CommandID_MAX = CommandID_SAVE
};

inline const CommandID (&EnumValuesCommandID())[8]
{
    static const CommandID values[] = {CommandID_OPEN,
                                       CommandID_CLOSE,
                                       CommandID_SET,
                                       CommandID_GET,
                                       CommandID_RET,
                                       CommandID_ERR,
                                       CommandID_RES,
                                       CommandID_SAVE};
    return values;
}

inline const char* const* EnumNamesCommandID()
{
    static const char* const names[9]
        = {"OPEN", "CLOSE", "SET", "GET", "RET", "ERR", "RES", "SAVE", nullptr};
    return names;
}

inline const char* EnumNameCommandID(CommandID e)
{
    if (::flatbuffers::IsOutRange(e, CommandID_OPEN, CommandID_SAVE))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesCommandID()[index];
}

enum VariableID : int8_t
{
    VariableID_config_name = 0,
    VariableID_config_version = 1,
    VariableID_config_last_revision_date = 2,
    VariableID_torque_map = 3,
    VariableID_inverter_mode = 4,
    VariableID_disable_torque_requests = 5,
    VariableID_apps_1_adc_min = 6,
    VariableID_apps_1_adc_max = 7,
    VariableID_apps_2_adc_min = 8,
    VariableID_apps_2_adc_max = 9,
    VariableID_bps_adc_min = 10,
    VariableID_bps_adc_max = 11,
    VariableID_bps_fully_pressed_threshold = 12,
    VariableID_enable_lapsim_testbench = 13,
    VariableID_lapsim_testbench_laps = 14,
    VariableID_MIN = VariableID_config_name,
    VariableID_MAX = VariableID_lapsim_testbench_laps
};

inline const VariableID (&EnumValuesVariableID())[15]
{
    static const VariableID values[] = {VariableID_config_name,
                                        VariableID_config_version,
                                        VariableID_config_last_revision_date,
                                        VariableID_torque_map,
                                        VariableID_inverter_mode,
                                        VariableID_disable_torque_requests,
                                        VariableID_apps_1_adc_min,
                                        VariableID_apps_1_adc_max,
                                        VariableID_apps_2_adc_min,
                                        VariableID_apps_2_adc_max,
                                        VariableID_bps_adc_min,
                                        VariableID_bps_adc_max,
                                        VariableID_bps_fully_pressed_threshold,
                                        VariableID_enable_lapsim_testbench,
                                        VariableID_lapsim_testbench_laps};
    return values;
}

inline const char* const* EnumNamesVariableID()
{
    static const char* const names[16] = {"config_name",
                                          "config_version",
                                          "config_last_revision_date",
                                          "torque_map",
                                          "inverter_mode",
                                          "disable_torque_requests",
                                          "apps_1_adc_min",
                                          "apps_1_adc_max",
                                          "apps_2_adc_min",
                                          "apps_2_adc_max",
                                          "bps_adc_min",
                                          "bps_adc_max",
                                          "bps_fully_pressed_threshold",
                                          "enable_lapsim_testbench",
                                          "lapsim_testbench_laps",
                                          nullptr};
    return names;
}

inline const char* EnumNameVariableID(VariableID e)
{
    if (::flatbuffers::IsOutRange(e,
                                  VariableID_config_name,
                                  VariableID_lapsim_testbench_laps))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesVariableID()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Version FLATBUFFERS_FINAL_CLASS
{
private:

    int8_t a_;
    int8_t b_;
    int8_t c_;

public:

    Version() : a_(0), b_(0), c_(0)
    {
    }
    Version(int8_t _a, int8_t _b, int8_t _c)
        : a_(::flatbuffers::EndianScalar(_a)),
          b_(::flatbuffers::EndianScalar(_b)),
          c_(::flatbuffers::EndianScalar(_c))
    {
    }
    int8_t a() const
    {
        return ::flatbuffers::EndianScalar(a_);
    }
    int8_t b() const
    {
        return ::flatbuffers::EndianScalar(b_);
    }
    int8_t c() const
    {
        return ::flatbuffers::EndianScalar(c_);
    }
};
FLATBUFFERS_STRUCT_END(Version, 3);

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef CommandBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ID = 4,
        VT_VAR = 6,
        VT_VAL = 8,
        VT_CONFIG_NAME = 10,
        VT_CONFIG_VERSION = 12
    };
    Comms::CommandID id() const
    {
        return static_cast<Comms::CommandID>(GetField<int8_t>(VT_ID, 0));
    }
    Comms::VariableID var() const
    {
        return static_cast<Comms::VariableID>(GetField<int8_t>(VT_VAR, 0));
    }
    int32_t val() const
    {
        return GetField<int32_t>(VT_VAL, 0);
    }
    const ::flatbuffers::String* config_name() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_CONFIG_NAME);
    }
    const Comms::Version* config_version() const
    {
        return GetStruct<const Comms::Version*>(VT_CONFIG_VERSION);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier)
               && VerifyField<int8_t>(verifier, VT_ID, 1)
               && VerifyField<int8_t>(verifier, VT_VAR, 1)
               && VerifyField<int32_t>(verifier, VT_VAL, 4)
               && VerifyOffset(verifier, VT_CONFIG_NAME)
               && verifier.VerifyString(config_name())
               && VerifyField<Comms::Version>(verifier, VT_CONFIG_VERSION, 1)
               && verifier.EndTable();
    }
};

struct CommandBuilder
{
    typedef Command Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_id(Comms::CommandID id)
    {
        fbb_.AddElement<int8_t>(Command::VT_ID, static_cast<int8_t>(id), 0);
    }
    void add_var(Comms::VariableID var)
    {
        fbb_.AddElement<int8_t>(Command::VT_VAR, static_cast<int8_t>(var), 0);
    }
    void add_val(int32_t val)
    {
        fbb_.AddElement<int32_t>(Command::VT_VAL, val, 0);
    }
    void
    add_config_name(::flatbuffers::Offset<::flatbuffers::String> config_name)
    {
        fbb_.AddOffset(Command::VT_CONFIG_NAME, config_name);
    }
    void add_config_version(const Comms::Version* config_version)
    {
        fbb_.AddStruct(Command::VT_CONFIG_VERSION, config_version);
    }
    explicit CommandBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Command> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Command>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Command>
CreateCommand(::flatbuffers::FlatBufferBuilder& _fbb,
              Comms::CommandID id = Comms::CommandID_OPEN,
              Comms::VariableID var = Comms::VariableID_config_name,
              int32_t val = 0,
              ::flatbuffers::Offset<::flatbuffers::String> config_name = 0,
              const Comms::Version* config_version = nullptr)
{
    CommandBuilder builder_(_fbb);
    builder_.add_config_version(config_version);
    builder_.add_config_name(config_name);
    builder_.add_val(val);
    builder_.add_var(var);
    builder_.add_id(id);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<Command>
CreateCommandDirect(::flatbuffers::FlatBufferBuilder& _fbb,
                    Comms::CommandID id = Comms::CommandID_OPEN,
                    Comms::VariableID var = Comms::VariableID_config_name,
                    int32_t val = 0,
                    const char* config_name = nullptr,
                    const Comms::Version* config_version = nullptr)
{
    auto config_name__ = config_name ? _fbb.CreateString(config_name) : 0;
    return Comms::CreateCommand(_fbb,
                                id,
                                var,
                                val,
                                config_name__,
                                config_version);
}

} // namespace Comms

#endif // FLATBUFFERS_GENERATED_SCHEMA_COMMS_H_
